(window.webpackJsonp=window.webpackJsonp||[]).push([[34],{465:function(_,v,t){"use strict";t.r(v);var r=t(16),a=Object(r.a)({},(function(){var _=this,v=_.$createElement,t=_._self._c||v;return t("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[t("h1",{attrs:{id:"用户空间与内核空间"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#用户空间与内核空间"}},[_._v("#")]),_._v(" 用户空间与内核空间")]),_._v(" "),t("h2",{attrs:{id:"铺垫"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#铺垫"}},[_._v("#")]),_._v(" 铺垫")]),_._v(" "),t("h3",{attrs:{id:"内存地址空间"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#内存地址空间"}},[_._v("#")]),_._v(" 内存地址空间")]),_._v(" "),t("p",[_._v("我们知道操作系统采用的是虚拟地址空间，比如在32位操作系统当中，其寻址空间为2^32次幂，也就是4G大小，在这里列举两个概念：")]),_._v(" "),t("ol",[t("li",[_._v("寻址：寻址指的是操作系统能够找到的地址范围，这里的32位主要指的是地址总线的位数，当然也和CPU寄存器的位数、操作系统能够提供的最大位数有关系。对于一个32位的二进制数，每一位可以是0或者1，那么就有2^32次幂种可能，那么访问的范围也就是4G这么大；")]),_._v(" "),t("li",[_._v("虚拟地址空间：说其虚拟是因为，虽然内存一共就4G，但操作系统为每一个进程都分配了4G的内存空间，这个内存空间实际上是虚拟的，虚拟内存到物理内存有一个映射关系。如X86 CPU采用的是段页式地址映射模型；")])]),_._v(" "),t("p",[_._v("操作系统将这4G可访问的内存空间划分为了两部分：用户空间和内核空间。")]),_._v(" "),t("p",[_._v("内核空间是操作系统内核访问的区域，独立于普通的应用程序，是受保护的内存空间。")]),_._v(" "),t("p",[_._v("以linux操作系统为例，将最高的1G字节（从虚拟地址0xC0000000到0xFFFFFFFF），供内核使用，称为内核空间，而将较低的3G字节（从虚拟地址0x00000000到0xBFFFFFFF），供各个进程使用，称为用户空间。")]),_._v(" "),t("p",[_._v("每个进程可以通过系统调用进入内核，因此，Linux内核由系统内的所有进程共享。于是，从具体进程的角度来看，每个进程可以拥有4G字节的虚拟空间。")]),_._v(" "),t("blockquote",[t("p",[_._v("什么是操作系统内核？详见下一篇文章。")])]),_._v(" "),t("h2",{attrs:{id:"为何要区分用户空间和内核空间"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#为何要区分用户空间和内核空间"}},[_._v("#")]),_._v(" 为何要区分用户空间和内核空间？")]),_._v(" "),t("p",[_._v("其实早期操作系统是不区分内核空间和用户空间的，但是应用程序能访问任意内存空间，如果程序不稳定常常把系统搞崩溃，比如清除操作系统的内存数据。后来觉得让应用程序随便访问内存太危险了，硬件设备商直接提供硬件级别的支持，将CPU指令分为四个级别：")]),_._v(" "),t("ul",[t("li",[t("strong",[_._v("Ring0~Ring3")]),_._v(" (和电影分级有点像)，linux 只使用了 "),t("strong",[_._v("Ring0")]),_._v(" 和 "),t("strong",[_._v("Ring3")]),_._v(" 两个运行级别，进程运行在 Ring3 级别时运行在用户态，指令只访问用户空间，而运行在 Ring0 级别时被称为运行在内核态，可以访问任意内存空间。")])]),_._v(" "),t("blockquote",[t("p",[_._v("CPU有一个状态指示寄存器，这个寄存器可以控制CPU当前工作于ring0还是ring1、2、3。")])]),_._v(" "),t("p",[_._v("用户态的程序不能随意操作内核地址空间，这样对操作系统具有一定的安全保护作用。")]),_._v(" "),t("h4",{attrs:{id:"什么是cpu指令集权限"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么是cpu指令集权限"}},[_._v("#")]),_._v(" 什么是CPU指令集权限？")]),_._v(" "),t("p",[_._v("指令集是 CPU 实现软件指挥硬件执行的媒介，具体来说每一条汇编语句都对应了一条 "),t("code",[_._v("CPU 指令")]),_._v("，而非常非常多的 "),t("code",[_._v("CPU 指令")]),_._v(" 在一起，可以组成一个、甚至多个集合，指令的集合叫 "),t("code",[_._v("CPU 指令集")]),_._v("。")]),_._v(" "),t("h2",{attrs:{id:"什么是用户态和内核态"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么是用户态和内核态"}},[_._v("#")]),_._v(" 什么是用户态和内核态？")]),_._v(" "),t("p",[_._v("其实很清晰："),t("strong",[_._v("当进程/线程运行在内核空间时就处于内核态，而进程/线程运行在用户空间时则处于用户态。")]),_._v("「用户态与内核态只是不同权限的资源范围」。")]),_._v(" "),t("p",[_._v("在内核态下，进程运行在内核地址空间中，此时 CPU 可以执行任何指令。运行的代码也不受任何的限制，可以自由地访问任何有效地址，也可以直接进行端口的访问。")]),_._v(" "),t("p",[_._v("在用户态下，进程运行在用户地址空间中，被执行的代码要受到 CPU 的很多检查，比如：进程只能访问映射其地址空间的页表项中规定的在用户态下可访问页面的虚拟地址。")]),_._v(" "),t("blockquote",[t("p",[_._v("每个进程都有两个栈，分别是用户栈与内核栈，对应用户态与内核态的使用。")])]),_._v(" "),t("h2",{attrs:{id:"用户态到内核态的切换"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#用户态到内核态的切换"}},[_._v("#")]),_._v(" 用户态到内核态的切换？")]),_._v(" "),t("p",[t("a",{attrs:{href:"https://imgtu.com/i/jO4K3D",target:"_blank",rel:"noopener noreferrer"}},[t("img",{attrs:{src:"https://s1.ax1x.com/2022/07/22/jO4K3D.jpg",alt:"jO4K3D.jpg"}}),t("OutboundLink")],1)]),_._v(" "),t("p",[_._v("如上图所示，所有系统资源的管理都是在内存空间进行的，也就是在内核态去做的，那我们应用程序需要访问磁盘，读取网卡的数据，新建一个线程都需要通过系统调用接口，完成从用户态到内存态的切换。")]),_._v(" "),t("p",[_._v("比如我们 Java 中需要新建一个线程，"),t("code",[_._v("new Thread( Runnable ...)")]),_._v(" 之后调用 "),t("code",[_._v("start()")]),_._v(" 方法时, 看Hotspot Linux 的JVM 源码实现，最终是调"),t("code",[_._v("pthread_create")]),_._v(" 系统方法来创建的线程，这里会从用户态切换到内核态完成系统资源的分配，线程的创建。")]),_._v(" "),t("p",[t("strong",[_._v("当一个任务（进程）执行系统调用而陷入内核代码中执行时，称进程处于内核运行态（内核态）")])]),_._v(" "),t("p",[_._v("过程如下：")]),_._v(" "),t("ol",[t("li",[_._v("保留用户态现场（上下文、寄存器、用户栈等等）")]),_._v(" "),t("li",[_._v("复制用户态参数、用户栈到内核栈，进入内核态（压栈）")]),_._v(" "),t("li",[_._v("额外的检查（内核不信任用户，需要进行地址范围校验等等）")]),_._v(" "),t("li",[_._v("执行内核态代码")]),_._v(" "),t("li",[_._v("复制内核态代码执行的结果，回到用户态")]),_._v(" "),t("li",[_._v("恢复用户态现场（上下文、寄存器、用户栈等等）")])]),_._v(" "),t("h4",{attrs:{id:"什么时候会导致用户态到内核态的切换"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#什么时候会导致用户态到内核态的切换"}},[_._v("#")]),_._v(" 什么时候会导致用户态到内核态的切换？")]),_._v(" "),t("ol",[t("li",[_._v("系统调用：用户态进程主动切换到内核态的方式，用户态进程通过系统调用向操作系统申请资源完成工作，例如 fork() 就是一个创建新进程的系统调用，系统调用的机制核心使用了操作系统；")]),_._v(" "),t("li",[_._v("异常：当 CPU 在执行用户态的进程时，发生了一些没有预知的异常，这时当前运行进程会切换到处理此异常的内核相关进程中，也就是切换到了内核态，如缺页异常；")]),_._v(" "),t("li",[_._v("中断：当 CPU 在执行用户态的进程时，外围设备完成用户请求的操作后，会向 CPU  发出相应的中断信号，这时 CPU 会暂停执行下一条即将要执行的指令，转到与中断信号对应的处理程序去执行，也就是切换到了内核态。如硬盘读写操作完成，系统会切换到硬盘读写的中断处理程序中执行后边的操作等。")])]),_._v(" "),t("h2",{attrs:{id:"附加问题"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#附加问题"}},[_._v("#")]),_._v(" 附加问题")]),_._v(" "),t("p",[_._v("linux在系统调用进入内核时，为什么要将参数从用户空间拷贝到内核空间？不能直接访问，或是使用memcpy吗？非要使用copy_from_user才行吗？"),t("a",{attrs:{href:"https://www.zhihu.com/question/19728793",target:"_blank",rel:"noopener noreferrer"}},[_._v("问题链接"),t("OutboundLink")],1)]),_._v(" "),t("p",[_._v("引用一位大佬的回答：")]),_._v(" "),t("blockquote",[t("p",[_._v("首先，"),t("strong",[_._v("内核不能信任任何用户空间的指针。必须对用户空间的指针指向的数据进行验证。如果只做验证不做拷贝的话，那么在随后的运行中要随时受到其它进／线程可能修改用户空间数据的威胁。所以必须做拷贝。")]),_._v("（有人提到在 copy 过程中数据依然可以被修改。是的，但是这种修改不能称为「篡改」。因为这种修改是在「合法性检查」之前发生的，影响的是用户进程的正确性，而不是内核对数据的验证。copy 只保证最后被使用的数据是被验证的数据，至于有没有 race 去破坏被传入的数据本身的正确性不在内核责任之内。要注意，「合法性」不等于「正确性」。）")]),_._v(" "),t("p",[_._v("linux在系统调用进入内核时，为什么要将参数从用户空间拷贝到内核空间？不能直接访问，或是使用memcpy吗？非要使用copy_from_user才行吗？ - 冯东的回答 - 知乎 https://www.zhihu.com/question/19728793/answer/137716739")])])])}),[],!1,null,null,null);v.default=a.exports}}]);