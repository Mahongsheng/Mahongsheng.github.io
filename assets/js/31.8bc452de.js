(window.webpackJsonp=window.webpackJsonp||[]).push([[31],{462:function(v,_,t){"use strict";t.r(_);var a=t(16),s=Object(a.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("h1",{attrs:{id:"进程线程的诞生"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#进程线程的诞生"}},[v._v("#")]),v._v(" 进程线程的诞生")]),v._v(" "),t("p",[v._v("进程线程到底有哪些区别？应该从其诞生的意义来说起。")]),v._v(" "),t("h2",{attrs:{id:"操作系统发展史"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#操作系统发展史"}},[v._v("#")]),v._v(" 操作系统发展史")]),v._v(" "),t("h3",{attrs:{id:"早期的计算机-单指令模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#早期的计算机-单指令模式"}},[v._v("#")]),v._v(" 早期的计算机（单指令模式）")]),v._v(" "),t("p",[v._v("在计算机刚出现的时候，是为了解决数学计算的问题，因为很多大量的计算通过人力去完成是很耗时间和人力成本的。")]),v._v(" "),t("p",[v._v("在最初的时候，计算机只能接受一些特定的指令，用户输入一个指令，计算机就做一个操作。当用户在思考或者输入数据时，计算机就在等待。显然这样效率和很低下，因为很多时候，计算机处于等待用户输入的状态。")]),v._v(" "),t("h3",{attrs:{id:"批处理模式-多指令模式"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#批处理模式-多指令模式"}},[v._v("#")]),v._v(" 批处理模式（多指令模式）")]),v._v(" "),t("p",[v._v("把一系列需要操作的指令预先写下来，形成一个清单，然后一次性交给计算机，计算机不断地去读取指令来进行相应的操作。用户可以将需要执行的多个程序写在磁带上，然后交由计算机去读取并逐个地执行这些程序，并将输出结果写到另一个磁带上。")]),v._v(" "),t("blockquote",[t("p",[v._v("缺点：假如有两个任务A和B，任务A在执行到一半的过程中，需要读取大量的数据输入（I/O操作，很耗时），而此时CPU只能静静地等待任务A读取完数据才能继续执行，这样就白白浪费了CPU资源。")])]),v._v(" "),t("p",[v._v("CPU陷入等待，这种情况显然又回到了最初的那种单指令模式，得想办法让CPU正常的干活。设想下，能不能让指令间进行切换呢？比如任务A阻塞了，那么CPU收回时间片，让后面的任务B去执行。想法很合理，但是要让指令间进行切换的话，肯定得将所有指令隔离起来。指令如何隔离？其实难度相当大，于是乎引入了进程。")]),v._v(" "),t("h2",{attrs:{id:"进程的诞生"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#进程的诞生"}},[v._v("#")]),v._v(" 进程的诞生")]),v._v(" "),t("p",[v._v("人们想能否在任务A读取数据的过程中，让任务B去执行，当任务A读取完数据之后，让任务B暂停，然后让任务A继续执行？那么问题来了—— 原来每次都是一个程序在计算机里面运行，也就说内存中始终只有一个程序的运行数据。如果想要任务A在执行I/O操作的时候，让任务B去执行，必然内存中要装入多个程序，那么如何处理呢？多个程序使用的数据如何进行辨别呢？并且当一个程序运行暂停后，后面如何恢复到它之前执行的状态呢？")]),v._v(" "),t("p",[v._v("于是人们发明了进程，用进程来对应一个程序，每个进程对应一定的内存地址空间，并且只能使用它自己的内存空间，各个进程间互不干扰。并且进程保存了程序每个时刻的运行状态，这样就为进程切换提供了可能。当进程暂停时，它会保存当前进程的状态（比如进程标识、进程的使用的资源等），在下一次重新切换回来时，便根据之前保存的状态进行恢复，然后继续执行。")]),v._v(" "),t("blockquote",[t("p",[v._v("缺点：一个进程在一个时间段内只能做一件事情，如果一个进程有多个子任务，只能逐个地去执行这些子任务。")]),v._v(" "),t("p",[v._v("对于一个电商系统而言，它不仅要把图像数据显示在画面上，还要与服务端进行通信获取商品数据，还要处理用户的交互操作。如果一个进程中，每次只能执行一个任务，对于电商系统而言，用户可能需要一直等待，直到所有的操作在单个进程中处理完。显然，这样的系统，显示是无法满足用户的需求的。")])]),v._v(" "),t("h2",{attrs:{id:"线程的诞生"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#线程的诞生"}},[v._v("#")]),v._v(" 线程的诞生")]),v._v(" "),t("p",[v._v("可不可以将进程中这些子任务分开执行呢？即在系统获取商品数据的同时，如果用户点击了某个按钮，则会暂停获取图像数据，而先去响应用户的操作（因为用户的操作往往执行时间很短），在处理完用户操作之后，再继续获取商品数据。于是人们发明了线程。")]),v._v(" "),t("p",[v._v("让一个线程去执行一个子任务，这样一个进程就包括了多个线程，每个线程负责一个独立的子任务，这样在用户点击按钮的时候，就可以暂停获取商品数据的线程，让图像线程响应用户的操作，响应完之后再切换回来，让获取图像的线程得到CPU资源。从而让用户感觉系统是同时在做多件事情的，满足了用户对实时性的要求。")]),v._v(" "),t("p",[t("em",[v._v("简单的说")])]),v._v(" "),t("p",[v._v("​        "),t("em",[v._v("——进程让操作系统的并发性成为可能。")])]),v._v(" "),t("p",[v._v("​        "),t("em",[v._v("——线程让进程的内部并发成为可能。")])]),v._v(" "),t("h2",{attrs:{id:"引用一个故事"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#引用一个故事"}},[v._v("#")]),v._v(" 引用一个故事")]),v._v(" "),t("p",[v._v("计算机的核心就是CPU，所有的计算都在CPU中进行处理。CPU像是一个工厂，时刻运行着。")]),v._v(" "),t("p",[v._v("假定工厂的电力有限，一次只能供给一个车间使用。进程就好比工厂的车间，它代表CPU所能处理的单个任务。任一时刻，CPU总是运行一个进程，其他进程处于非运行状态。")]),v._v(" "),t("ul",[t("li",[t("p",[v._v("一个车间里，可以有很多工人。他们协同完成一个任务。")])]),v._v(" "),t("li",[t("p",[v._v("线程就好比车间里的工人。一个进程可以包括多个线程。")])]),v._v(" "),t("li",[t("p",[v._v("车间的空间是工人们共享的，比如许多房间是每个工人都可以进出的。这象征一个进程的内存空间是共享的，每个线程都可以使用这些共享内存。")])]),v._v(" "),t("li",[t("p",[v._v("每间房间的大小不同，有些房间最多只能容纳一个人，比如厕所。")])]),v._v(" "),t("li",[t("p",[v._v("当这个房间里面有人的时候，其他人就不能进去了。这代表一个线程使用某些共享内存时，其他线程必须等它结束，才能使用这一块内存。")])]),v._v(" "),t("li",[t("p",[v._v('一个防止他人进入厕所的简单方法，就是门口加一把锁。先到的人锁上门，后到的人看到上锁，就在门口排队，等锁打开再进去。这就叫"互斥锁"（Mutual exclusion，缩写 Mutex），防止多个线程同时读写某一块内存区域。')])]),v._v(" "),t("li",[t("p",[v._v('还有些房间，可以同时容纳n个人，比如餐厅或者茶水间。也就是说，如果人数大于n，多出来的人只能在外面等着。这好比某些内存区域，只能供给固定数目的线程使用。这时的解决方法，就是在门口挂n把钥匙。进去的人就取一把钥匙，出来时再把钥匙挂回原处。后到的人发现钥匙架空了，就知道必须在门口排队等着了。这种做法叫做"信号量"（Semaphore），用来保证多个线程不会互相冲突。不难看出，锁是semaphore的一种特殊情况（n=1时）。也就是说，完全可以用后者替代前者。但是，因为锁较为简单，且效率高，所以在必须保证资源独占的情况下，还是采用这种设计。')])])]),v._v(" "),t("p",[v._v("操作系统的设计，因此可以归结为三点：")]),v._v(" "),t("ol",[t("li",[v._v("以多进程形式，允许多个任务同时运行；")]),v._v(" "),t("li",[v._v("以多线程形式，允许每个任务分成不同的部分运行；")]),v._v(" "),t("li",[v._v("提供协调机制，一方面防止进程之间和线程之间产生冲突，另一方面允许进程之间和线程之间共享资源。")])]),v._v(" "),t("h2",{attrs:{id:"appendix"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#appendix"}},[v._v("#")]),v._v(" Appendix")]),v._v(" "),t("p",[v._v("CPU 核心指的是物理核心，即 CPU 内部的独立的核心单元组，为中心计算单元，通常情况下一个核心对应一个线程，但超线程技术的提出可以使得一个核心可以对应多个线程，类似于银行工作窗口和工作人员，前者为核心，后者为多个线程，一个窗口可以有多个工作人员，一个工作人员的业务阻塞的时候可以切换到另一个工作人员。")])])}),[],!1,null,null,null);_.default=s.exports}}]);