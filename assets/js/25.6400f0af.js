(window.webpackJsonp=window.webpackJsonp||[]).push([[25],{456:function(_,v,o){"use strict";o.r(v);var r=o(16),t=Object(r.a)({},(function(){var _=this,v=_.$createElement,o=_._self._c||v;return o("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[o("h1",{attrs:{id:"mongodb与mysql对比"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#mongodb与mysql对比"}},[_._v("#")]),_._v(" MongoDB与MySQL对比")]),_._v(" "),o("p",[_._v("在我们的项目进行技术选型的时候，常常面临着选择关系型数据库还是Key-Value数据库的问题，下面对主要对这两种数据库中的代表MySQL和MongoDB做一个对比。")]),_._v(" "),o("h2",{attrs:{id:"mongodb优缺点"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#mongodb优缺点"}},[_._v("#")]),_._v(" MongoDB优缺点")]),_._v(" "),o("p",[_._v("优点：")]),_._v(" "),o("ol",[o("li",[_._v("面向文档存储，基于JSON/BSON 可表示灵活的数据结构；")]),_._v(" "),o("li",[_._v("动态 DDL能力，没有强Schema约束，支持快速迭代；")]),_._v(" "),o("li",[_._v("MongoDB在内存充足的情况下数据都放入内存且有完整的索引支持，查询效率较高；")]),_._v(" "),o("li",[_._v("MongoDB的分片机制，支持海量数据的存储和扩展；")])]),_._v(" "),o("p",[_._v("缺点：")]),_._v(" "),o("ol",[o("li",[_._v("不支持事务；")]),_._v(" "),o("li",[_._v("不支持join、复杂查询；")])]),_._v(" "),o("h2",{attrs:{id:"bson-数据类型"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#bson-数据类型"}},[_._v("#")]),_._v(" BSON 数据类型")]),_._v(" "),o("p",[_._v("曾经，JSON 的出现及流行让 Web 2.0 的数据传输变得非常简单，所以使用 JSON 语法是非常容易让开发者接受的。")]),_._v(" "),o("p",[_._v("但是 JSON 也有自己的短板，比如无法支持像日期这样的特定数据类型，因此 MongoDB 实际上使用的是一种扩展式的JSON，叫 BSON(Binary JSON)。")]),_._v(" "),o("h2",{attrs:{id:"分布式id"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#分布式id"}},[_._v("#")]),_._v(" 分布式ID")]),_._v(" "),o("p",[_._v("在单机时代，大多数应用可以使用数据库自增式ID 来作为主键。 传统的 RDBMS 也都支持这种方式，比如 mysql 可以通过声明 auto_increment来实现自增的主键。 但一旦数据实现了分布式存储，这种方式就不再适用了，原因就在于无法保证多个节点上的主键不出现重复。")]),_._v(" "),o("p",[_._v("为了实现分布式数据ID的唯一性保证，应用开发者提出了自己的方案，而大多数方案中都会将ID分段生成，如著名的 snowflake 算法中就同时使用了时间戳、机器号、进程号以及随机数来保证唯一性。")]),_._v(" "),o("p",[_._v("MongoDB 采用 ObjectId 来表示主键的类型，数据库中每个文档都拥有一个_id 字段表示主键。")]),_._v(" "),o("p",[_._v("_id 的生成规则如下：")]),_._v(" "),o("p",[o("a",{attrs:{href:"https://imgtu.com/i/jlMoFO",target:"_blank",rel:"noopener noreferrer"}},[o("img",{attrs:{src:"https://s1.ax1x.com/2022/07/01/jlMoFO.png",alt:"jlMoFO.png"}}),o("OutboundLink")],1)]),_._v(" "),o("p",[_._v("其中包括：")]),_._v(" "),o("ul",[o("li",[_._v("4-byte Unix 时间戳")]),_._v(" "),o("li",[_._v("3-byte 机器 ID")]),_._v(" "),o("li",[_._v("2-byte 进程 ID")]),_._v(" "),o("li",[_._v("3-byte 计数器(初始化随机)")])]),_._v(" "),o("p",[_._v("值得一提的是 "),o("code",[_._v("_id")]),_._v(" 的生成实质上是由客户端(Driver)生成的，这样可以获得更好的随机性，同时降低服务端的负载。当然服务端也会检测写入的文档是否包含"),o("code",[_._v("_id")]),_._v("字段，如果没有就生成一个。")]),_._v(" "),o("h2",{attrs:{id:"索引"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#索引"}},[_._v("#")]),_._v(" 索引")]),_._v(" "),o("p",[_._v("在当前的版本中 MongoDB 使用 wiredTiger 作为默认的引擎。")]),_._v(" "),o("p",[_._v("在索引的实现上使用了 B+树的结构，这与其他的传统数据库并没有什么不同。\n所以这是个好消息，"),o("strong",[_._v("大部分基于SQL数据库的一些索引调优技巧在 MongoDB 上仍然是可行的")]),_._v("。")]),_._v(" "),o("p",[_._v("MongoDB支持老化数据，如expireAfterSeconds=3600表示这是一个TTL索引，并且数据将在1小时后老化并被删除。")]),_._v(" "),o("p",[_._v("索引分类：")]),_._v(" "),o("p",[_._v("除了普通索引之外，MongoDB 支持的类型还包括：")]),_._v(" "),o("ul",[o("li",[_._v("哈希(HASH)索引，哈希是另一种快速检索的数据结构，MongoDB 的 HASH 类型分片键会使用"),o("a",{attrs:{href:"https://www.zhihu.com/search?q=%E5%93%88%E5%B8%8C%E7%B4%A2%E5%BC%95&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22article%22%2C%22sourceId%22%3A%2287722764%22%7D",target:"_blank",rel:"noopener noreferrer"}},[_._v("哈希索引"),o("OutboundLink")],1),_._v("。")]),_._v(" "),o("li",[_._v("地理空间索引，用于支持快速的地理空间查询，如寻找附近1公里的商家。")]),_._v(" "),o("li",[_._v("文本索引，用于支持快速的全文检索")]),_._v(" "),o("li",[_._v("模糊索引(Wildcard Index)，一种基于匹配规则的灵活式索引，在4.2版本开始引入。")])]),_._v(" "),o("h2",{attrs:{id:"mongodb的应用场景"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#mongodb的应用场景"}},[_._v("#")]),_._v(" MongoDB的应用场景")]),_._v(" "),o("ol",[o("li",[_._v("表结构不明确且数据不断变大\n"),o("ul",[o("li",[_._v("MongoDB是非结构化文档数据库，扩展字段很容易且不会影响原有数据。内容管理或者博客平台等，例如圈子系统，存储用户评论之类的；")])])]),_._v(" "),o("li",[_._v("更高的写入负载\n"),o("ul",[o("li",[_._v("MongoDB侧重高数据写入的性能，而非事务安全，适合业务系统中有大量“低价值”数据的场景。本身存的就是json格式数据。例如做日志系统；")])])]),_._v(" "),o("li",[_._v("数据量很大或者将来会变得很大\n"),o("ul",[o("li",[_._v("Mysql单表数据量达到5-10G时会出现明细的性能降级，需要做数据的水平和垂直拆分、库的拆分完成扩展，MongoDB内建了sharding、很多数据分片的特性，容易水平扩展，比较好的适应大数据量增长的需求；")])])]),_._v(" "),o("li",[_._v("高可用性\n"),o("ul",[o("li",[_._v("自带高可用，自动主从切换（副本集）；")])])])]),_._v(" "),o("p",[_._v("不适用的场景：")]),_._v(" "),o("ol",[o("li",[_._v("MongoDB不支持事务操作，需要用到事务的应用建议不用MongoDB；")]),_._v(" "),o("li",[_._v("MongoDB目前不支持join操作，需要复杂查询的应用也不建议使用MongoDB；")])]),_._v(" "),o("h2",{attrs:{id:"关系型数据库和非关系型数据库的应用场景对比"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#关系型数据库和非关系型数据库的应用场景对比"}},[_._v("#")]),_._v(" 关系型数据库和非关系型数据库的应用场景对比")]),_._v(" "),o("p",[_._v("关系型数据库适合存储结构化数据，如用户的帐号、地址：")]),_._v(" "),o("ol",[o("li",[_._v("这些数据通常需要做结构化查询，比如join，这时候，关系型数据库就要胜出一筹；")]),_._v(" "),o("li",[_._v("这些数据的规模、增长的速度通常是可以预期的；")]),_._v(" "),o("li",[_._v("事务性、一致性；")])]),_._v(" "),o("p",[_._v("NoSQL适合存储非结构化数据，如文章、评论：")]),_._v(" "),o("ol",[o("li",[_._v("这些数据通常用于模糊处理，如全文搜索、机器学习；")]),_._v(" "),o("li",[_._v("这些数据是海量的，而且增长的速度是难以预期的；")]),_._v(" "),o("li",[_._v("根据数据的特点，NoSQL数据库通常具有无限（至少接近）伸缩性；")]),_._v(" "),o("li",[_._v("按key获取数据效率很高，但是对join或其他结构化查询的支持就比较差；")])]),_._v(" "),o("h2",{attrs:{id:"总结"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#总结"}},[_._v("#")]),_._v(" 总结")]),_._v(" "),o("h3",{attrs:{id:"mongodb"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#mongodb"}},[_._v("#")]),_._v(" MongoDB：")]),_._v(" "),o("p",[o("strong",[_._v("更高的写入负载")])]),_._v(" "),o("p",[_._v("默认情况下，MongoDB更侧重高数据写入性能，而非事务安全，MongoDB很适合业务系统中有大量“低价值”数据的场景。但是应当避免在高事务安全性的系统中使用MongoDB，除非能从架构设计上保证事务安全。")]),_._v(" "),o("p",[o("strong",[_._v("高可用性")])]),_._v(" "),o("p",[_._v("MongoDB的复副集(Master-Slave)配置非常简洁方便，此外，MongoDB可以快速响应的处理单节点故障，自动、安全的完成故障转移。这些特性使得MongoDB能在一个相对不稳定（如云主机）的环境中，保持高可用性。")]),_._v(" "),o("p",[o("strong",[_._v("数据量很大或者未来会变得很大")])]),_._v(" "),o("p",[_._v("依赖数据库(MySQL)自身的特性，完成数据的扩展是较困难的事，在MySQL中，当一个"),o("a",{attrs:{href:"https://www.zhihu.com/search?q=%E5%8D%95%E8%BE%BE%E8%A1%A8&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A%222286449236%22%7D",target:"_blank",rel:"noopener noreferrer"}},[_._v("单达表"),o("OutboundLink")],1),_._v("到5-10GB时会出现明显的性能降级，此时需要通过数据的水平和垂直拆分、库的拆分完成扩展，使用MySQL通常需要借助"),o("a",{attrs:{href:"https://www.zhihu.com/search?q=%E9%A9%B1%E5%8A%A8%E5%B1%82&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A%222286449236%22%7D",target:"_blank",rel:"noopener noreferrer"}},[_._v("驱动层"),o("OutboundLink")],1),_._v("或代理层完成这类需求。而MongoDB内建了多种数据分片的特性，可以很好的适应大数据量的需求。")]),_._v(" "),o("p",[o("strong",[_._v("基于位置的数据查询")])]),_._v(" "),o("p",[_._v("MongoDB支持二维空间索引，因此可以快速及精确的从指定位置获取数据。")]),_._v(" "),o("p",[o("strong",[_._v("表结构不明确，且数据在不断变大")])]),_._v(" "),o("p",[_._v("在一些传统RDBMS中，增加一个字段会锁住整个数据库/表，或者在执行一个重负载的请求时会明显造成其它请求的性能降级。通常发生在数据表大于1G的时候（当大于1TB时更甚）。 因MongoDB是文档型数据库，为非结构货的文档增加一个新字段是很快速的操作，并且不会影响到已有数据。另外一个好处当业务数据发生变化时，是将不在需要由DBA修改表结构。")]),_._v(" "),o("h3",{attrs:{id:"mysql"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#mysql"}},[_._v("#")]),_._v(" Mysql：")]),_._v(" "),o("ol",[o("li",[_._v("这些数据通常需要做结构化查询，比如join，这时候，关系型数据库就要胜出一筹")]),_._v(" "),o("li",[_._v("这些数据的规模、增长的速度通常是可以预期的")]),_._v(" "),o("li",[_._v("事务性、一致性")]),_._v(" "),o("li",[_._v("丰富的锁机制")])]),_._v(" "),o("p",[_._v("更多关于MongoDB可以看这篇文章：")]),_._v(" "),o("blockquote",[o("p",[_._v("了解 MongoDB 看这一篇就够了 - 华为云开发者联盟的文章 - 知乎 https://zhuanlan.zhihu.com/p/87722764")])])])}),[],!1,null,null,null);v.default=t.exports}}]);