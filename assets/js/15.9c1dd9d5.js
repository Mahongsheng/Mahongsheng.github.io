(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{446:function(_,t,v){"use strict";v.r(t);var r=v(16),T=Object(r.a)({},(function(){var _=this,t=_.$createElement,v=_._self._c||t;return v("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[v("p",[_._v("HTTP协议规定了不同方法的安全性和幂等性，作为服务提供者的服务器必需为客户端提供这些特性。")]),_._v(" "),v("h2",{attrs:{id:"_1-安全性"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-安全性"}},[_._v("#")]),_._v(" 1. 安全性")]),_._v(" "),v("p",[_._v("安全性指的是方法执行后不会并不会改变资源的表述。即调用不会产生副作用，这里并不涉及传统意义上的“安全”，其副作用是指资源状态。即安全的方法不会修改资源状态或服务器状态，尽管多次调用的返回值可能不一样（被其他非安全方法修改过）。")]),_._v(" "),v("h2",{attrs:{id:"_2-幂等性"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-幂等性"}},[_._v("#")]),_._v(" 2. 幂等性")]),_._v(" "),v("p",[_._v("幂等性指的是方法无论执行多少次都会得到同样的结果。客户端可以重复调用并且期望同样的结果。幂等的含义类似于编程语言的setter，一次调用和多次调用产生的效果是一致的，都是对一个变量进行赋值。安全性和幂等性含义有些接近，容易搞混。")]),_._v(" "),v("h2",{attrs:{id:"_3-http方法的安全性和幂等性"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-http方法的安全性和幂等性"}},[_._v("#")]),_._v(" 3. HTTP方法的安全性和幂等性：")]),_._v(" "),v("table",[v("thead",[v("tr",[v("th",[_._v("方法名")]),_._v(" "),v("th",[_._v("安全性")]),_._v(" "),v("th",[_._v("幂等性")])])]),_._v(" "),v("tbody",[v("tr",[v("td",[_._v("GET")]),_._v(" "),v("td",[_._v("是")]),_._v(" "),v("td",[_._v("是")])]),_._v(" "),v("tr",[v("td",[_._v("HEAD")]),_._v(" "),v("td",[_._v("是")]),_._v(" "),v("td",[_._v("是")])]),_._v(" "),v("tr",[v("td",[_._v("OPTIONS")]),_._v(" "),v("td",[_._v("是")]),_._v(" "),v("td",[_._v("是")])]),_._v(" "),v("tr",[v("td",[_._v("DELETE")]),_._v(" "),v("td",[_._v("否")]),_._v(" "),v("td",[_._v("是")])]),_._v(" "),v("tr",[v("td",[_._v("PUT")]),_._v(" "),v("td",[_._v("否")]),_._v(" "),v("td",[_._v("是")])]),_._v(" "),v("tr",[v("td",[_._v("POST")]),_._v(" "),v("td",[_._v("否")]),_._v(" "),v("td",[_._v("否")])]),_._v(" "),v("tr",[v("td",[_._v("PATCH")]),_._v(" "),v("td",[_._v("否")]),_._v(" "),v("td",[_._v("否")])])])]),_._v(" "),v("p",[v("strong",[_._v("注意：")])]),_._v(" "),v("ul",[v("li",[_._v("安全的方法都是幂等的。在表格中，我们可以看到"),v("strong",[_._v("安全的方法都是只读的方法")]),_._v("（GET、HEAD、OPTIONS），不会改变资源状态，显然，这三个方法也是幂等。")]),_._v(" "),v("li",[_._v("DELETE方法的语义表示删除服务器上一个资源，第一次删除成功后该资源就不存在了，资源状态改变了，所以DELETE方法不具备安全特性。然而HTTP协议规定DELETE方法是幂等，每次删除该资源都要返回状态码200 OK，服务器端要实现幂等的DELETE方法，必须记录所有已删除资源的元数据（Metadata），否则，第二次删除后返回的响应码就会类似404 Not Found了。")]),_._v(" "),v("li",[_._v("PUT 和POST方法语义中都有修改资源状态的意思，因此都不是安全。但是PUT方法是幂等的，POST方法不是幂等的，这么设计的理由是：HTTP协议规定，POST方法修改资源状态时，URL指示的是该资源的父级资源，待修改资源的ID在请求中携带。而PUT方法修改资源状态时，URL直接指示待修改资源。因此，同样是创建资源，重复提交POST请求可能产生两个不同的资源，而重复提交PUT请求只会对其URL中指定的资源起作用，也就是只会创建一个资源。")]),_._v(" "),v("li",[_._v("PATCH是PUT的补充，表示对资源的局部更新。PATCH是不幂等的，这主要考虑到若资源中存在version字段，每次更改会对version进行++操作，那么多次PATCH操作实际上不会得到相同结果。而PUT操作是全量更新，直接将服务器资源进行替换，所以我们认为多次替换幂等。")])]),_._v(" "),v("h2",{attrs:{id:"_4-http方法对应的crud操作"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-http方法对应的crud操作"}},[_._v("#")]),_._v(" 4. HTTP方法对应的CRUD操作")]),_._v(" "),v("table",[v("thead",[v("tr",[v("th",[_._v("方法名")]),_._v(" "),v("th",[_._v("CRUD")])])]),_._v(" "),v("tbody",[v("tr",[v("td",[_._v("GET")]),_._v(" "),v("td",[_._v("READ")])]),_._v(" "),v("tr",[v("td",[_._v("DELETE")]),_._v(" "),v("td",[_._v("DELETE")])]),_._v(" "),v("tr",[v("td",[_._v("PUT")]),_._v(" "),v("td",[_._v("UPDATE 全量更新")])]),_._v(" "),v("tr",[v("td",[_._v("POST")]),_._v(" "),v("td",[_._v("CREATE")])]),_._v(" "),v("tr",[v("td",[_._v("PATCH")]),_._v(" "),v("td",[_._v("UPDATE 局部更新")])])])]),_._v(" "),v("p",[v("strong",[_._v("补充：")])]),_._v(" "),v("ol",[v("li",[_._v("HEAD：HEAD和GET本质是一样的，区别在于HEAD不含有呈现数据，而仅仅是HTTP头信息。有的人可能觉得这个方法没什么用，其实不是这样的。想象一个业务情景：欲判断某个资源是否存在，我们通常使用GET，但这里用HEAD则意义更加明确。")]),_._v(" "),v("li",[_._v("OPTIONS：这个方法很有趣，但极少使用。它用于获取当前URL所支持的方法。若请求成功，则它会在HTTP头中包含一个名为“Allow”的头，指的是所支持的方法，如“GET，POST”等等。")]),_._v(" "),v("li",[_._v("TRACE：其让我们的服务器端将客户端的所有请求信息原样返回给客户端，该方法多见于debug的需求")])])])}),[],!1,null,null,null);t.default=T.exports}}]);