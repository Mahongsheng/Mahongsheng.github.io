(window.webpackJsonp=window.webpackJsonp||[]).push([[63],{495:function(t,r,v){"use strict";v.r(r);var a=v(16),e=Object(a.a)({},(function(){var t=this,r=t.$createElement,v=t._self._c||r;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h1",{attrs:{id:"d-separation-一种概率图结构独立性的判断方法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#d-separation-一种概率图结构独立性的判断方法"}},[t._v("#")]),t._v(" d-separation-一种概率图结构独立性的判断方法")]),t._v(" "),v("p",[t._v("很多的机器学习模型都可以用概率的角度去解释（可以看MLAPP和PRML这两本书），其中一类重要的模型就是概率图模型，而概率图模型的灵魂就是模型变量间的"),v("strong",[t._v("条件独立性")]),t._v("。 因为有了独立性，才有了各种不同的概率图模型，比如LDA,HMM等等模型。那么概率图中，变量间的独立性是怎么体现的呢？d-分离准则就是一种简单的技巧去判断一个概率图中的独立性的。")]),t._v(" "),v("p",[t._v("简单的说，如果在概率图模型中，比如说X，Y两个节点没有边来使得X和Y之间肯定存在某种独立性，这种独立性可以是在某个子集Z的条件下使得他们独立，也可能是他们两个本身就是独立的，这时我们称X，Y之间是d-分离的。")]),t._v(" "),v("h2",{attrs:{id:"d-分离的准则"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#d-分离的准则"}},[t._v("#")]),t._v(" "),v("strong",[t._v("d-分离的准则：")])]),t._v(" "),v("p",[t._v("**定义：**当且仅当以下条件成立时，我们说路径P被结点集Z d-separate（或被Blocked）：")]),t._v(" "),v("ol",[v("li",[t._v("若"),v("code",[t._v("P")]),t._v("包含形式如下的链："),v("code",[t._v("i -> m -> j")]),t._v("或者"),v("code",[t._v("i <- m -> j")]),t._v("，则结点"),v("code",[t._v("m")]),t._v("在集合"),v("code",[t._v("Z")]),t._v("中；")]),t._v(" "),v("li",[t._v("若"),v("code",[t._v("P")]),t._v("中包含"),v("code",[t._v("collider")]),t._v("（碰撞点）"),v("code",[t._v("i -> m <- j")]),t._v("，则结点"),v("code",[t._v("m")]),t._v("不在"),v("code",[t._v("Z")]),t._v("中且"),v("code",[t._v("m")]),t._v("的子代也不在"),v("code",[t._v("Z")]),t._v("中；")])]),t._v(" "),v("p",[t._v("更进一步说，如果Z将X和Y进行了d-分离时，当且仅当Z将X，Y之间的每一条路径都block掉。")]),t._v(" "),v("p",[t._v("接下来逐步的介绍上述的准则，我们可以拆分成3个规则来考虑：")]),t._v(" "),v("p",[t._v("首先，这里我们先说明一下path，我们说两个结点之间的path的时候是不管他们之间边的方向的。")]),t._v(" "),v("h2",{attrs:{id:"没有条件集的独立性"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#没有条件集的独立性"}},[t._v("#")]),t._v(" 没有条件集的独立性")]),t._v(" "),v("p",[v("strong",[t._v("规则1")]),t._v("：如果x到y的任一path(路径)都经过collider(碰撞点)，则x和y独立。注意，这里的路径是忽略边的方向的，而碰撞点是指有多个箭头指向的它的节点，即类似于下图的"),v("code",[t._v("s -> t <- u")]),t._v("。\n$$\nx \\Rightarrow r \\Rightarrow s \\Rightarrow t \\Leftarrow u \\Leftarrow v \\Rightarrow y\n$$\n现在我们看看这个图变量之间的独立性是怎样的。先考虑x和t的路径："),v("code",[t._v("x-r-s-t")]),t._v("。这条路径中并不存在碰撞点，所以x和t不独立，同样地，t和y、u、v都不独立。然而，对于变量x到y而言，x，y之间的路径必然会经过碰撞点t，所以x和y是独立，同样地，在碰撞点两侧的变量都是独立的，比如x和v，s和u，r和u也是独立的。")]),t._v(" "),v("h2",{attrs:{id:"一般的条件独立"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#一般的条件独立"}},[t._v("#")]),t._v(" 一般的条件独立")]),t._v(" "),v("p",[t._v("那么如果一条路径中没有碰撞点，怎么才能让他们独立呢？我们还能使用条件独立的性质，只要条件集Z能够将一条路径block掉，那么就可以让两个变量独立。注意的是，当碰撞点或碰撞点的子代出现在条件集的时候要小心，很有可能会导致不同的结果，这个问题我们留到规则3。现在我们先假设条件集中不存在碰撞点。")]),t._v(" "),v("p",[v("strong",[t._v("规则2")]),t._v("："),v("em",[t._v("当x到y的之间的任一路径都经过Z中的节点，且Z并不包含碰撞点或碰撞点的子代，则x和y独立。")]),t._v("\n$$\nx \\Rightarrow \\underline{r} \\Rightarrow s \\Rightarrow t \\Leftarrow u \\Leftarrow \\underline{v} \\Rightarrow y\n$$\n如图，设结点集"),v("code",[t._v("Z={r, v}")]),t._v("（图中下划线的节点），根据规则2，x和s是条件独立的，因为x和s之间的路径被block掉了，同样地，u和y也是条件独立的。")]),t._v(" "),v("h2",{attrs:{id:"当collider作为条件集"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#当collider作为条件集"}},[t._v("#")]),t._v(" 当collider作为条件集")]),t._v(" "),v("p",[t._v("现在我们先看看collider成为条件集的时候会发生什么。我们考虑一个例子：")]),t._v(" "),v("div",{staticClass:"language-mermaid line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[t._v("graph TD\n    A(IQ) --\x3e B(成绩)\n    C(难度) --\x3e B(成绩)\n    B(成绩) --\x3e D(ABCD等级)\n")])]),t._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[t._v("1")]),v("br"),v("span",{staticClass:"line-number"},[t._v("2")]),v("br"),v("span",{staticClass:"line-number"},[t._v("3")]),v("br"),v("span",{staticClass:"line-number"},[t._v("4")]),v("br")])]),v("p",[t._v("这里显然IQ和难度是独立的，他们共同决定成绩的高低，于是成绩是一个collider，而不同成绩会导致不同排名，所以排名是成绩的子代。现在如果我们已经知道一个人的成绩是多少，那么神奇的事情发生了，如果我们知道一个人IQ很低，但成绩很高，那么我们可以推断出难度肯定很低；同理我们知道成绩很高，但难度很大，那么可以推断出IQ很高。原本IQ和难度两个独立的变量在成绩的条件下变得不独立的。")]),t._v(" "),v("p",[t._v("同理，因为ABCD等级是由不同成绩划分出来的，也包含了成绩的信息，所以我们知道一个人的等级同样可以推断出一个人的IQ和难度。因此当条件集是collider的时候，会反而使得两个独立的变量变得不独立。这就是我们判断条件独立性的时候要小心的地方。接下来是规则3：")]),t._v(" "),v("p",[v("strong",[t._v("规则3")]),t._v("："),v("em",[t._v("当碰撞点或碰撞点的子孙节点为集合Z的成员时，该碰撞点不再截断路径。")])]),t._v(" "),v("div",{attrs:{align:"center"}},[v("img",{staticStyle:{zoom:"80%"},attrs:{src:"https://s1.ax1x.com/2022/04/07/LSNsKA.jpg",alt:"LSNsKA.jpg"}})]),t._v(" "),v("p",[t._v("设结点集"),v("code",[t._v("Z={r, p}")]),t._v("（图中画圈的节点），根据规则3，在给定Z的情况下，s和y不独立，因为t的孩子节点p在集合Z中，所以t没有办法像规则1一样截断路径s-t-u-v-y，与此相反，条件集p使得s和u变得不独立了。然而在这里，x和u是独立的，虽然t不能截断它，但是r可以截断它（根据规则2）。")])])}),[],!1,null,null,null);r.default=e.exports}}]);