(window.webpackJsonp=window.webpackJsonp||[]).push([[100],{532:function(t,e,s){"use strict";s.r(e);var a=s(16),n=Object(a.a)({},(function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("h1",{attrs:{id:"lab-2a"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#lab-2a"}},[t._v("#")]),t._v(" Lab 2A")]),t._v(" "),s("h2",{attrs:{id:"领导选举"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#领导选举"}},[t._v("#")]),t._v(" 领导选举")]),t._v(" "),s("h2",{attrs:{id:"日志复制"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#日志复制"}},[t._v("#")]),t._v(" 日志复制")]),t._v(" "),s("p",[t._v("日志复制是Raft集群高可用的实现方法，当一条日志被超过一半的机器收到之后，这条日志就被认为成功提交到Raft状态机。同时Raft通过日志复制保证集群的大多数机器的日志都是一致的。 日志复制主要在"),s("code",[t._v("Append")]),t._v("消息和"),s("code",[t._v("AppendResp")]),t._v("消息中完成，在这里，我们需要先对lab2aa实现的"),s("code",[t._v("handleAppendEntries")]),t._v("进行一些修改。首先考虑正常的收发消息流程。领导者按照保存在Prs的Next，发送Index是从Next到最后的日志，同时需要在消息中附加Next-1日志的任期和Index，我们直接把Append传来的消息追加到节点日志序列最后。然后我们需要考虑论文中的几个异常情况：")]),t._v(" "),s("p",[s("a",{attrs:{href:"https://imgtu.com/i/jHeeC8",target:"_blank",rel:"noopener noreferrer"}},[s("img",{attrs:{src:"https://s1.ax1x.com/2022/07/19/jHeeC8.png",alt:"jHeeC8.png"}}),s("OutboundLink")],1)]),t._v(" "),s("p",[t._v("下面针对不同的情况进行分类讨论：")]),t._v(" "),s("ol",[s("li",[t._v("图中的情况a和b是日志缺失的情况。这时我们通过检查"),s("code",[t._v("Follower")]),t._v("的日志有没有这个"),s("code",[t._v("Next-1")]),t._v("日志。如果没有，说明日志缺失，返回拒绝日志的"),s("code",[t._v("AppendResp")]),t._v("，消息要附加自己的最后一条日志的"),s("code",[t._v("Term")]),t._v("和"),s("code",[t._v("Index")]),t._v("。领导者收到拒绝的消息后更新这个节点的"),s("code",[t._v("Prs")]),t._v("的"),s("code",[t._v("Next和Match")]),t._v("到返回的"),s("code",[t._v("Index+1")]),t._v("和"),s("code",[t._v("Index")]),t._v("然后重发消息（这里需要实现成立即重发）")]),t._v(" "),s("li",[t._v("图中的情况c和d是日志过多的情况。这时"),s("code",[t._v("Follower")]),t._v("是有"),s("code",[t._v("Next-1")]),t._v("日志的，然后"),s("code",[t._v("Follower")]),t._v("在追加日志时就要把自己的和"),s("code",[t._v("Leader")]),t._v("日志不一致的地方丢掉，然后再追加日志")]),t._v(" "),s("li",[t._v("图中的情况e和f是日志冲突的情况，这是"),s("code",[t._v("Follower")]),t._v("没有"),s("code",[t._v("Next-1")]),t._v("日志，发送拒绝，同时附加和Append消息的Index对应的消息的Term，领导者手到这个拒收的时候找到小于等于该任期的Index最大的消息，然后重发，可以发现，多次调整之后，这个"),s("code",[t._v("Follower")]),t._v("的状态可以回到日志缺失的状态。同时领导者处理拒绝的流程和a，b状态下的是一致的。")])]),t._v(" "),s("h3",{attrs:{id:"数据结构解释"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#数据结构解释"}},[t._v("#")]),t._v(" 数据结构解释")]),t._v(" "),s("div",{staticClass:"language-go line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-go"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("type")]),t._v(" RaftLog "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("struct")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// storage contains all stable entries since the last snapshot.")]),t._v("\n    storage Storage\n\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// committed is the highest log position that is known to be in")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// stable storage on a quorum of nodes.")]),t._v("\n    committed "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("uint64")]),t._v("\n\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// applied is the highest log position that the application has")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// been instructed to apply to its state machine.")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Invariant: applied <= committed")]),t._v("\n    applied "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("uint64")]),t._v("\n\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// log entries with index <= stabled are persisted to storage.")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// It is used to record the logs that are not persisted by storage yet.")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// Everytime handling `Ready`, the unstabled logs will be included.")]),t._v("\n    stabled "),s("span",{pre:!0,attrs:{class:"token builtin"}},[t._v("uint64")]),t._v("\n\n    "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// all entries that have not yet compact.")]),t._v("\n    entries "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v("pb"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("Entry\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br"),s("span",{staticClass:"line-number"},[t._v("8")]),s("br"),s("span",{staticClass:"line-number"},[t._v("9")]),s("br"),s("span",{staticClass:"line-number"},[t._v("10")]),s("br"),s("span",{staticClass:"line-number"},[t._v("11")]),s("br"),s("span",{staticClass:"line-number"},[t._v("12")]),s("br"),s("span",{staticClass:"line-number"},[t._v("13")]),s("br"),s("span",{staticClass:"line-number"},[t._v("14")]),s("br"),s("span",{staticClass:"line-number"},[t._v("15")]),s("br"),s("span",{staticClass:"line-number"},[t._v("16")]),s("br"),s("span",{staticClass:"line-number"},[t._v("17")]),s("br"),s("span",{staticClass:"line-number"},[t._v("18")]),s("br"),s("span",{staticClass:"line-number"},[t._v("19")]),s("br"),s("span",{staticClass:"line-number"},[t._v("20")]),s("br"),s("span",{staticClass:"line-number"},[t._v("21")]),s("br")])]),s("ul",[s("li",[t._v("storage: 存储entries的部分，在Raft中，entries会存在内存和外存两个地方，storage就相当于外存，可以看到storage提供的接口里面是没有写操作的，这是因为entries写入外存是由外面的模块来决定的，Raft只负责管理内存中的entries（严格来说应该是管理commit之后的entries）")]),t._v(" "),s("li",[t._v("committed: Raft算法中的commit，即已经确认提交的日志位置")]),t._v(" "),s("li",[t._v("applied: 表示已经应用到状态机中的entries，值为applied entries的最大Index。这里要搞清楚的是，Raft只是用来管理entries的，真正使用entries中的log（比如说Get，Put，Delete操作）是外部的状态机，也就是最终的kv系统")]),t._v(" "),s("li",[t._v("stabled: 已经放到外存中的entries的最大Index")]),t._v(" "),s("li",[t._v("entries: 与storage相对应，内存中的entries")])]),t._v(" "),s("p",[t._v("如下图所示：")]),t._v(" "),s("p",[t._v("![TinyKV-Lab2A-1](C:\\Users\\Scott Ma\\Pictures\\博客图片\\TinyKV-Lab2A-1.png)")]),t._v(" "),s("p",[t._v("注意：当"),s("code",[t._v("len(r.RaftLog.entries) == 0")]),t._v("时，"),s("code",[t._v("len(ms.ents) == 1")]),t._v("，first为1，stabled和last为0。")])])}),[],!1,null,null,null);e.default=n.exports}}]);