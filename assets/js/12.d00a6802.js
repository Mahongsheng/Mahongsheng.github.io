(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{443:function(v,e,_){"use strict";_.r(e);var t=_(16),r=Object(t.a)({},(function(){var v=this,e=v.$createElement,_=v._self._c||e;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h1",{attrs:{id:"stringbuilder和stringbuffer"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#stringbuilder和stringbuffer"}},[v._v("#")]),v._v(" StringBuilder和StringBuffer")]),v._v(" "),_("p",[v._v("“标准答案”是“前者线程安全，后者线程不安全”。")]),v._v(" "),_("p",[v._v("但实际上这是一个历史遗留问题。")]),v._v(" "),_("h2",{attrs:{id:"万物皆可多线程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#万物皆可多线程"}},[v._v("#")]),v._v(" 万物皆可多线程")]),v._v(" "),_("p",[v._v("随着当时 CPU 主频和核心数的增长，为了充分利用 CPU 的算力，“并发”的概念应运而生。而支持多进程的类 UNIX 系统当时还是高端计算机的专利，大多数家用电脑使用的 DOS 和 Windows 系统使用多进程开销太大。所以，多线程在当时几乎是最佳的并发解决方案。然而，无论是 C 还是 C++，都原生不支持多线程。")]),v._v(" "),_("p",[v._v("Java 语言设计之初，就是为了替代（当时）极其复杂原始的 C/C++，其中的一个大改进就是，把并发（多线程）的理念贯彻到了语言的各个角落。想想当初 Java 设计者为什么要设计成所有对象都支持作为 "),_("code",[v._v("synchronized")]),v._v(" 代码块的互斥锁使用，还把 "),_("code",[v._v("wait")]),v._v("、"),_("code",[v._v("notify")]),v._v(" 等 "),_("code",[v._v("final")]),v._v(" 方法放到万物之源 "),_("code",[v._v("Object")]),v._v(" 类？")]),v._v(" "),_("p",[v._v("为什么最初几乎所有可变对象如 "),_("code",[v._v("StringBuffer")]),v._v("、"),_("code",[v._v("Vector")]),v._v("、"),_("code",[v._v("Hashtable")]),v._v("、"),_("code",[v._v("ByteArray{Input,Output}Stream")]),v._v(" 等都要设计成线程安全的？")]),v._v(" "),_("p",[v._v("因为当初的语言设计者认为多线程是万金油，这些可变对象几乎都会被多个线程同时修改，所以为了避免 Race Condition，也为了避免程序员频繁使用 "),_("code",[v._v("synchronized")]),v._v(" 代码块造成可读性和易用性降低，就把它们统统设计成“线程安全”的，让保持同步的脏活累活都留给标准库干，反正也不影响单线程下的准确性，无非损失亿点性能而已。")]),v._v(" "),_("p",[v._v("但事实证明，多个线程同时修改一个对象的场景才是少数，绝大多数可变对象只会被一个线程修改，然而因为频繁不必要的上锁、释放锁的操作，使得性能损失很大，所以你会看到，后来的 "),_("code",[v._v("ArrayList")]),v._v("、"),_("code",[v._v("HashMap")]),v._v(" 等可变类都不再默认线程安全，以此换取单线程下的性能提升，然后提供 "),_("code",[v._v("Collections.synchronizedXxx")]),v._v(" 等方法提供少数情况需要多线程安全的可变对象。")]),v._v(" "),_("h2",{attrs:{id:"纠正历史遗留问题"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#纠正历史遗留问题"}},[v._v("#")]),v._v(" 纠正历史遗留问题")]),v._v(" "),_("p",[v._v("这个问题的主角 "),_("code",[v._v("StringBuffer")]),v._v(" 和 "),_("code",[v._v("StringBuilder")]),v._v(" 也是一样的，后者就是为纠正历史遗留问题，提高单线程下的性能而生的，而为了向下兼容性和需要线程安全的场景，才保留 "),_("code",[v._v("StringBuffer")]),v._v(" 类。")]),v._v(" "),_("p",[v._v("随着内存越来越大，函数式编程的“万物皆 immutable”的思想流行，Java 也出现越来越多的不可变类，例如 "),_("code",[v._v("java.time")]),v._v(" 包中的类、"),_("code",[v._v("Optional")]),v._v(" 类、 "),_("code",[v._v("List.of")]),v._v("、"),_("code",[v._v("Set.of")]),v._v(" 返回的不可变集合等。这才是多进程、多线程下保证准确性、提升性能的新的解决方案。")])])}),[],!1,null,null,null);e.default=r.exports}}]);