(window.webpackJsonp=window.webpackJsonp||[]).push([[135],{567:function(_,v,r){"use strict";r.r(v);var e=r(16),t=Object(e.a)({},(function(){var _=this,v=_.$createElement,r=_._self._c||v;return r("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[r("h1",{attrs:{id:"eco跨境电商平台总结"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#eco跨境电商平台总结"}},[_._v("#")]),_._v(" ECO跨境电商平台总结")]),_._v(" "),r("h2",{attrs:{id:"_1-架构"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_1-架构"}},[_._v("#")]),_._v(" 1. 架构")]),_._v(" "),r("p",[r("strong",[_._v("微服务架构：")])]),_._v(" "),r("ol",[r("li",[_._v("基础信息模块；")]),_._v(" "),r("li",[_._v("商品管理模块；")]),_._v(" "),r("li",[_._v("订单模块；")]),_._v(" "),r("li",[_._v("电子钱包模块；")]),_._v(" "),r("li",[_._v("管理员模块；")])]),_._v(" "),r("p",[r("strong",[_._v("为什么这么分？")])]),_._v(" "),r("ul",[r("li",[_._v("单一职责（低耦合）；")]),_._v(" "),r("li",[_._v("面向服务（高内聚）；")])]),_._v(" "),r("p",[r("strong",[_._v("改成DDD？")])]),_._v(" "),r("ul",[r("li",[_._v("限界上下文；")]),_._v(" "),r("li",[_._v("改善贫血症；")]),_._v(" "),r("li",[_._v("业务与代码相匹配；")])]),_._v(" "),r("h2",{attrs:{id:"_2-springcloud与dubbo"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_2-springcloud与dubbo"}},[_._v("#")]),_._v(" 2. SpringCloud与Dubbo")]),_._v(" "),r("p",[_._v("根据一篇2017年的文章，Dubbo的性能大约是SpringCloud的3倍，"),r("a",{attrs:{href:"https://mp.weixin.qq.com/s?__biz=MzA5MzQ2NTY0OA==&mid=2650796496&idx=1&sn=a544b76660484b9914b65f038cc39e6d&chksm=88562c8fbf21a5995909ffa9f172f31651b1ebd04897917e43caef3491954e24ed0d0477a5a1&mpshare=1&scene=23&srcid=01245faqrBlQETYK9c7zVmd3#rd",target:"_blank",rel:"noopener noreferrer"}},[_._v("文章链接"),r("OutboundLink")],1),_._v("；")]),_._v(" "),r("p",[_._v("两者底层实现的协议不同：")]),_._v(" "),r("blockquote",[r("p",[_._v("由于Spring Cloud与Dubbo天生使用的协议层面不一样，前者是HTTP，后者是TCP(使用的是Netty NIO框架，序列化使用的阿里定制版Hessian2)，导致两个框架的性能差距略大；")]),_._v(" "),r("p",[_._v("dubbo由于是二进制的传输，占用带宽会更少；springCloud是http协议传输，带宽会比较多，同时使用http协议一般会使用JSON报文，消耗会更大；")])]),_._v(" "),r("p",[_._v("两者使用的注册中心不同：")]),_._v(" "),r("blockquote",[r("p",[_._v("Spring Cloud 使用的 eureka dubbo推荐使用zookeeper；")])]),_._v(" "),r("p",[r("strong",[_._v("ZooKeeper：")])]),_._v(" "),r("p",[_._v("Zookeeper保证了cp(一致性、分区容错性)，但是作为服务注册中心，我们可以容忍注册中心返回的是几分钟以前的注册信息。但是服务中心却必须保证可用性，")]),_._v(" "),r("p",[_._v("即服务注册中心对于高可用性的需求高于一致性。对于可用性，Zookeeper有一个leader选举方案。当master主节点宕机与其他节点失去联系时，其他节点会重新进行Leader选举，选出新的master节点。然而选举耗时过长，一般为30~120S，并且整个选举期间，整个zookeeper集群是无法使用的。")]),_._v(" "),r("p",[r("strong",[_._v("Eureka：")])]),_._v(" "),r("p",[_._v("Eureka保证了ap(可用性、分区容错性)，eureka每一个节点都是平等的，几个节点宕机不会影响正常节点的工作。剩余的正常节点依旧可以提供服务注册和查询。并且，当客户端向某节点注册服务时，注册失败或者超时，则会自动切换到其他节点。只要有一台Eureka节点还正常工作，就能保证注册服务的可用。但是对于服务信息的同步则不能保证一致性(不能保证强一致性，但是最终一致)。除此之外，Eureka还有一种自我保护机制，如果在15分钟内85%的节点都没有正常心跳(不可用)，那么Eureka就认为客户端与注册中心之间出现了网络故障，此时会出现以下几种情况：")]),_._v(" "),r("ol",[r("li",[_._v("Eureka不再从注册列表中移除因为长时间没收到心跳而应该过期的服务")]),_._v(" "),r("li",[_._v("Eureka仍然能够接收新服务的注册和查询请求，但是不会被同步到其他节点上(保证当前节点的可用性)")]),_._v(" "),r("li",[_._v("当网络稳定后，当前实例新注册的服务会被同步到其他节点")])]),_._v(" "),r("p",[r("strong",[_._v("为什么选择了SpringCloud？")])]),_._v(" "),r("p",[_._v("生态吧~")]),_._v(" "),r("h2",{attrs:{id:"_3-网关"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-网关"}},[_._v("#")]),_._v(" 3. 网关")]),_._v(" "),r("p",[r("strong",[_._v("为什么要有网关？")])]),_._v(" "),r("ol",[r("li",[_._v("隔离性：用户不必知道一次调用背后经历的服务有哪些；")]),_._v(" "),r("li",[_._v("健壮性：\n"),r("ol",[r("li",[_._v("限流：通过令牌桶等算法，把一些额外的流量挡在系统外面，不让其访问。")]),_._v(" "),r("li",[_._v("降级：由于系统可能已经过载了，此时，我们就放弃处理一些服务和页面的请求或者进行简单处理，比如直接返回一个报错。")]),_._v(" "),r("li",[_._v("熔断：有些时候，系统过载过度或者上线出了问题 bug，降级都解决不了问题。比如，缓存失效了，导致大量请求频繁访问了数据库，而这种频繁访问数据库可能造成了大量的 IO 操作，结果又影响了数据库所在的操作系统，同时，这个操作系统上又有着别的重要服务，直接也被影响了。对于这种连锁反应，我们称之为雪崩。而为了防止雪崩，我们就会坚决把缓存失效导致数据库被频繁访问的服务给停掉，这就是熔断。")])])]),_._v(" "),r("li",[_._v("安全性：鉴权；")]),_._v(" "),r("li",[_._v("解耦了客户端和后端微服务；")])]),_._v(" "),r("p",[r("strong",[_._v("网关怎么高可用？")])]),_._v(" "),r("ol",[r("li",[_._v("或许可以与keepalived这样的技术结合，实现主备机迅速切换；")])]),_._v(" "),r("h3",{attrs:{id:"_3-1-zuul"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-zuul"}},[_._v("#")]),_._v(" 3.1 Zuul")]),_._v(" "),r("p",[_._v("关于Zuul：")]),_._v(" "),r("ol",[r("li",[r("a",{attrs:{href:"https://mp.weixin.qq.com/s/ttL5gm_ZLAQL_uJ4iNtqsQ",target:"_blank",rel:"noopener noreferrer"}},[_._v("Spring Cloud Zuul：API网关服务"),r("OutboundLink")],1)]),_._v(" "),r("li",[r("a",{attrs:{href:"https://www.cnblogs.com/fengpinglangjingruma/p/13880832.html",target:"_blank",rel:"noopener noreferrer"}},[_._v("非常全面的讲解SpringCloud中Zuul网关原理及其配置，看它就够了！"),r("OutboundLink")],1)])]),_._v(" "),r("blockquote",[r("p",[_._v("Zuul中集成了Hystrix和Ribbon，前者用来限流和降级，后者用来负载均衡；")])]),_._v(" "),r("h2",{attrs:{id:"_4-hystrix"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_4-hystrix"}},[_._v("#")]),_._v(" 4. Hystrix")]),_._v(" "),r("p",[r("strong",[_._v("断路器，是一个分布式容错框架：")])]),_._v(" "),r("ol",[r("li",[_._v("阻止故障的连锁反应，实现熔断；")]),_._v(" "),r("li",[_._v("快速失败，实现优雅降级；")]),_._v(" "),r("li",[_._v("提供实时的监控和警告；")])]),_._v(" "),r("p",[r("strong",[_._v("资源隔离：线程隔离与信号量隔离：")])]),_._v(" "),r("ol",[r("li",[_._v("线程隔离：Hystix会给每一个Command分配一个单独的线程池，这样在进行单个服务调用的时候，就可以在独立的线程池里面进行，而不会对其他线程池造成影响；")]),_._v(" "),r("li",[_._v("信号量隔离：客户端需要向依赖服务发起请求时，首先要获得一个信号量才能真正发起调用，由于信号量的数量有限，当并发请求量高于信号量个数时，后续请求直接拒绝，进入Fallback流程，信号量隔离主要通过控制并发请求量，防止请求线程大面积阻塞，从而达到限流和防止雪崩的目的；")])]),_._v(" "),r("p",[r("strong",[_._v("熔断和降级：调用服务失败后快速失败；")])]),_._v(" "),r("p",[_._v("熔断是为了防止异常不扩散，保证系统的稳定性；")]),_._v(" "),r("p",[_._v("降级是编写好调用失败的补救逻辑，然后对服务直接停止运行，这样这些接口就无法正常调用，而又不至于直接报错，只是服务水平下降；")]),_._v(" "),r("ul",[r("li",[_._v("通过HystrixCommand或者HystrixObservableCommand将所有的外部系统（俗称依赖）包装起来，整个包装对象是单独运行在一个线程中（这是典型的命令模式）；")]),_._v(" "),r("li",[_._v("超时请求应该超过你设定的阈值；")]),_._v(" "),r("li",[_._v("为每个依赖维护一个小的线程池（或信号量），如果满了，则依赖关系的请求将立即被拒绝，而不是排队等待；")]),_._v(" "),r("li",[_._v("统计成功、失败、超时和线程拒绝；")]),_._v(" "),r("li",[_._v("打开断路器可以在一定时间内停止对特定服务的所有请求，如果服务的错误百分比通过阈值，则手动或自动的关闭断路器；")]),_._v(" "),r("li",[_._v("当请求被拒绝、连接超时或者断路器被打开，直接执行Fallback逻辑；")]),_._v(" "),r("li",[_._v("近乎实时的监控指标和配置变化；")])]),_._v(" "),r("h2",{attrs:{id:"_5-ribbon与feign"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_5-ribbon与feign"}},[_._v("#")]),_._v(" 5. Ribbon与Feign")]),_._v(" "),r("p",[r("strong",[_._v("Ribbon负载均衡原理是什么？")])]),_._v(" "),r("ol",[r("li",[_._v("Ribbon通过ILoadBalancer接口提供统一的Server (Server)功能，该接口会根据不同的负载均衡策略(IRule)选择合适的Server返回给用户。")]),_._v(" "),r("li",[_._v("IRule是负载均衡策略的抽象，ILoadBalancer通过调用IRule的choose()方法返回Server")]),_._v(" "),r("li",[_._v("IPing检查服务器是否可用，ILoadBalancer实现类维护一个Timer每10s检测一次服务器可用状态")]),_._v(" "),r("li",[_._v("IClientConfig主要定义用于初始化客户端和负载均衡器的配置信息，实现类forDefaultClientConfiglmpl")])]),_._v(" "),r("p",[r("strong",[_._v("什么是Feign？它解决了什么问题？")])]),_._v(" "),r("p",[_._v("Feign简化了RestTemplate的代码，实现了Ribbon的负载平衡，使代码更简洁，更少的客户端调用代码，使用Feign的负载平衡是首选的解决方案。只需要创建一个接口，然后在上面添加注释。Feign是一个调用组件的声明式服务，它的核心是:像调用本地方法一样调用远程方法，没有远程HTTP请求的感觉。")]),_._v(" "),r("ul",[r("li",[_._v("它解决了允许开发人员调用远程接口就像调用本地方法一样的体验，开发人员完全感知到这是一个远程方法，更不会感知到这是一个HTTP请求。细节上需要注意与远程的交互，更不需要注意分布式环境的开发。")]),_._v(" "),r("li",[_._v("它像Dubbo一样，消费者直接调用Provider接口的方法，而不需要通过Http请求客户端结构的常规分析数据再次返回。")])]),_._v(" "),r("h2",{attrs:{id:"_6-redis"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_6-redis"}},[_._v("#")]),_._v(" 6. Redis")]),_._v(" "),r("p",[r("strong",[_._v("为什么使用旁路缓存？")])]),_._v(" "),r("p",[r("strong",[_._v("Cache Aside Pattern 是我们平时使用比较多的一个缓存读写模式，比较适合读请求比较多的场景。")])]),_._v(" "),r("p",[_._v("Cache Aside Pattern 中服务端需要同时维系 DB 和 cache，并且是以 DB 的结果为准。")]),_._v(" "),r("p",[_._v("下面我们来看一下这个策略模式下的缓存读写步骤。")]),_._v(" "),r("p",[r("strong",[_._v("写")]),_._v(" ：")]),_._v(" "),r("ul",[r("li",[_._v("先更新 DB；")]),_._v(" "),r("li",[_._v("然后直接删除 cache；")])]),_._v(" "),r("p",[r("strong",[_._v("读")]),_._v(" :")]),_._v(" "),r("ul",[r("li",[_._v("从 cache 中读取数据，读取到就直接返回；")]),_._v(" "),r("li",[_._v("cache中读取不到的话，就从 DB 中读取数据返回；")]),_._v(" "),r("li",[_._v("再把数据放到 cache 中；")])]),_._v(" "),r("p",[_._v("商品是修改少，而读多的数据，因而使用旁路；")]),_._v(" "),r("p",[r("strong",[_._v("缓存了什么数据？")])]),_._v(" "),r("p",[_._v("主要是商品数据；")]),_._v(" "),r("h2",{attrs:{id:"_7-docker"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#_7-docker"}},[_._v("#")]),_._v(" 7. Docker")]),_._v(" "),r("p",[r("strong",[_._v("什么是Docker？")])]),_._v(" "),r("p",[_._v("Docker 是基于"),r("strong",[_._v("容器技术")]),_._v("实现的，容器技术最开始是基于 Linux Container（简称 LXC）技术实现的，通过内核提供的 "),r("code",[_._v("Namespace")]),_._v(" 和 "),r("code",[_._v("Cgroup")]),_._v(" 机制，实现了对应用程序的"),r("strong",[_._v("隔离")]),_._v("以及物理资源的"),r("strong",[_._v("分配")]),_._v("。")]),_._v(" "),r("p",[r("strong",[_._v("Docker 和虚拟机的区别？")])]),_._v(" "),r("p",[_._v("容器技术和虚拟机都提供了"),r("strong",[_._v("环境隔离")]),_._v("的功能。不同的是。容器是运行在操作系统上的一个进程，它和其他应用程序是共享内核的，由"),r("strong",[_._v("操作系统")]),_._v("提供虚拟化隔离功能；而虚拟机则是完完全全"),r("strong",[_._v("另")]),_._v("起了个操作系统，将环境隔离的更加彻底。")]),_._v(" "),r("p",[_._v("vm与docker框架，直观上来讲vm多了一层"),r("strong",[_._v("guest OS")]),_._v("，同时Hypervisor会对硬件资源进行虚拟化，docker直接使用硬件资源**，所以资源利用率相对docker低**。")]),_._v(" "),r("p",[_._v("深入一下，转载自知乎：")]),_._v(" "),r("blockquote",[r("p",[_._v("lxc 是 Linux 内核容器虚拟化的一项技术，可以实现资源的隔离和控制，也就是对 Cgroup 和 Namespace 两个属性的控制。")]),_._v(" "),r("p",[_._v("对于 docker 而言，它发展到现在不仅仅是容器的代名词了，不过它的基础技术是需要依赖内核的 Cgroup 和 Namespace 特性。docker 出现之初，便是采用了 lxc 技术作为 docker 底层，对容器虚拟化的控制。后来随着 docker 的发展，它自己封装了 libcontainer （"),r("a",{attrs:{href:"https://www.zhihu.com/search?q=golang&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A%22335458760%22%7D",target:"_blank",rel:"noopener noreferrer"}},[_._v("golang"),r("OutboundLink")],1),_._v(" 的库）来实现 Cgroup 和 Namespace 控制，从而消除了对 "),r("a",{attrs:{href:"https://www.zhihu.com/search?q=lxc&search_source=Entity&hybrid_search_source=Entity&hybrid_search_extra=%7B%22sourceType%22%3A%22answer%22%2C%22sourceId%22%3A%22335458760%22%7D",target:"_blank",rel:"noopener noreferrer"}},[_._v("lxc"),r("OutboundLink")],1),_._v(" 的依赖。")]),_._v(" "),r("p",[r("strong",[_._v("总结一下，lxc 是早期版本 docker 的一个基础组件，docker 主要用到了它对 Cgroup 和 Namespace 两个内核特性的控制。")])]),_._v(" "),r("p",[_._v("作者：lecury\n链接：https://www.zhihu.com/question/268288911/answer/335458760\n来源：知乎\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。")])])])}),[],!1,null,null,null);v.default=t.exports}}]);