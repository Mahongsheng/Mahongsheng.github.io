(window.webpackJsonp=window.webpackJsonp||[]).push([[29],{460:function(t,e,v){"use strict";v.r(e);var _=v(16),a=Object(_.a)({},(function(){var t=this,e=t.$createElement,v=t._self._c||e;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h1",{attrs:{id:"tcp快速重传为什么是三次冗余ack"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#tcp快速重传为什么是三次冗余ack"}},[t._v("#")]),t._v(" TCP快速重传为什么是三次冗余ACK？")]),t._v(" "),v("h2",{attrs:{id:"情景分析"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#情景分析"}},[t._v("#")]),t._v(" 情景分析")]),t._v(" "),v("p",[v("strong",[t._v("这是因为两次duplicated ACK肯定是乱序造成的！")])]),t._v(" "),v("p",[v("strong",[t._v("丢包肯定会造成三次duplicated ACK！")])]),t._v(" "),v("p",[t._v("假定通信双方如下，A发送4个TCP Segment 给B，编号如下，N-1成功到达，因为A收到B的ACK(N)，其它按照到达顺序，分别收到ACK(N)的数目：")]),t._v(" "),v("blockquote",[v("p",[t._v("A ---------\x3e B")]),t._v(" "),v("p",[v("strong",[t._v("A方发送顺序")]),t._v("N-1，N，N+1，N+2")]),t._v(" "),v("p",[v("strong",[t._v("B方到达顺序")])]),t._v(" "),v("p",[t._v("N-1，N，N+1，N+2 => A收到1个ACK (N)")]),t._v(" "),v("p",[t._v("N-1，N，N+2，N+1 => A收到1个ACK (N)")]),t._v(" "),v("p",[t._v("N-1，N+1，N，N+2 => A收到2个ACK (N)")]),t._v(" "),v("p",[v("strong",[t._v("N-1，N+1，N+2，N")]),t._v(" => A收到3个ACK (N)")]),t._v(" "),v("p",[t._v("N-1，N+2，N，N+1 => A收到2个ACK (N)")]),t._v(" "),v("p",[v("strong",[t._v("N-1，N+2，N+1，N")]),t._v(" => A收到3个ACK(N)")]),t._v(" "),v("p",[v("strong",[t._v("如果N丢了，没有到达B")])]),t._v(" "),v("p",[v("strong",[t._v("N-1，N+1，N+2")]),t._v(" => A收到3个ACK (N)")]),t._v(" "),v("p",[v("strong",[t._v("N-1，N+2，N+1")]),t._v(" => A收到3个ACK (N)")])]),t._v(" "),v("p",[t._v("TCP segment 乱序 有2/5 = "),v("strong",[t._v("40% 的概率")]),t._v("会造成A收到三次 duplicated ACK(N)；")]),t._v(" "),v("p",[t._v("而如果N丢了，则会"),v("strong",[t._v("100%概率")]),t._v("A会收到三次duplicated ACK(N)；")]),t._v(" "),v("p",[t._v("基于以上的统计，当A接收到三次 duplicated ACK(N)启动 Fast Retransmit 算法是合理的，即立马retransmit N，可以起到Fast Recovery的功效，快速修复一个丢包对TCP管道的恶劣影响。")]),t._v(" "),v("p",[t._v("而如果A接收到二次 duplicated ACK(N)，则一定说明是乱序造成的，即然是乱序，说明数据都到达了B，B的TCP负责重新排序而已，没有必要A再来启动Fast Retransmit算法。")]),t._v(" "),v("h2",{attrs:{id:"乱序由来"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#乱序由来"}},[t._v("#")]),t._v(" 乱序由来")]),t._v(" "),v("p",[v("strong",[t._v("TCP segment 乱序的由来")])]),t._v(" "),v("p",[t._v("TCP segment 封装在IP包里，如果IP包乱序，则相应TCP也会乱序，乱序的原因一般如下：")]),t._v(" "),v("p",[v("strong",[t._v("1）ECMP 负载均衡")])]),t._v(" "),v("p",[t._v("多路径的负载均衡，基于per-packet load balance，比如 packet 1，3，5…走路径1，packet 2，4，6…走路径2，很难保证packet 1 在 packet 2 之前到达目的地。")]),t._v(" "),v("p",[t._v("Per-session load balance 会基于TCP五元组来负载均衡，同一个TCP会话会走同一条路径，克服多路径造成的乱序。")]),t._v(" "),v("p",[v("strong",[t._v("2）路由器内部流量调度")])]),t._v(" "),v("p",[t._v("有些路由器采用多个流量处理单元，比如packet 1，3，5…由处理单元1来处理，packet 2，4，6…由处理单元2来处理，也很难保证packet 1 在 packet 2 之前到达目的地。")]),t._v(" "),v("p",[t._v("TCP接收到乱序的segment，会放在自己的接收缓冲区，等所有乱序的segment 都顺利到达，TCP重新排序，并将数据提交给 application。")]),t._v(" "),v("p",[t._v("乱序的segment 会占用接收缓冲区，直接造成B advertised window size 变小，造成对方A发送window 一直在变小，影响A发送效率。")]),t._v(" "),v("p",[t._v("即使A不快速重传，最后也会由retransmit timer timeout 超时重传，但这个时候A的发送window 非常小，发送速率也从天上掉到了地下。")]),t._v(" "),v("blockquote",[v("p",[t._v("在没有fast retransmit / recovery 算法之前，重传依靠发送方的retransmit timeout，就是在timeout内如果没有接收到对方的ACK，默认包丢了，发送方就重传，包的丢失原因 "),v("strong",[t._v("1）包checksum 出错 2）网络拥塞 3）网络断，包括路由重收敛")]),t._v("，但是发送方无法判断是哪一种情况，于是采用最笨的办法，就是将自己的发送速率减半，即CWND 减为1/2，这样的方法对2是有效的，可以缓解网络拥塞，3则无所谓，反正网络断了，无论发快发慢都会被丢；但对于1来说，丢包是因为偶尔的出错引起，一丢包就对半减速不合理。于是有了fast retransmit 算法，基于在反向还可以接收到ACK，可以认为网络并没有断，否则也接收不到ACK，如果在timeout 时间内没有接收到> 2 的duplicated ACK，则概率大事件为乱序，乱序无需重传，接收方会进行排序工作；而如果接收到三个或三个以上的duplicated ACK，则大概率是丢包，可以逻辑推理，发送方可以接收ACK，则网络是通的，可能是1、2造成的，先不降速，重传一次，如果接收到正确的ACK，则一切OK，流速依然（包出错被丢）。而如果依然接收到duplicated ACK，则认为是网络拥塞造成的，此时降速则比较合理。")])]),t._v(" "),v("p",[t._v("致敬原作者：")]),t._v(" "),v("p",[v("a",{attrs:{href:"https://www.zhihu.com/question/21789252/answer/110640581",target:"_blank",rel:"noopener noreferrer"}},[t._v("TCP 快速重传为什么是三次冗余 ACK，这个三次是怎么定下来的？"),v("OutboundLink")],1),t._v(" - 车小胖的回答 - 知乎")])])}),[],!1,null,null,null);e.default=a.exports}}]);