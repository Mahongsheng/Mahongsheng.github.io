(window.webpackJsonp=window.webpackJsonp||[]).push([[27],{458:function(o,e,s){"use strict";s.r(e);var t=s(16),_=Object(t.a)({},(function(){var o=this,e=o.$createElement,s=o._self._c||e;return s("ContentSlotsDistributor",{attrs:{"slot-key":o.$parent.slotKey}},[s("h2",{attrs:{id:"_1-背景"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1-背景"}},[o._v("#")]),o._v(" 1. 背景")]),o._v(" "),s("h3",{attrs:{id:"http是一个无状态协议"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#http是一个无状态协议"}},[o._v("#")]),o._v(" "),s("strong",[o._v("Http是一个无状态协议")])]),o._v(" "),s("p",[o._v("什么是无状态呢？就是说这一次请求和上一次请求是没有任何关系的，互不认识的，没有关联的。这种无状态的的好处是快速。也正因为如此，为了能够确定用户的权限并使得某个域名下的所有网页能够共享某些数据，Cookie，Session和Token出现了。")]),o._v(" "),s("h2",{attrs:{id:"_2-cookie和session"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-cookie和session"}},[o._v("#")]),o._v(" 2. Cookie和Session")]),o._v(" "),s("h3",{attrs:{id:"_2-1-什么是cookie"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-什么是cookie"}},[o._v("#")]),o._v(" 2.1 什么是Cookie")]),o._v(" "),s("p",[o._v("cookie是一个非常具体的东西，指的就是浏览器里面能永久存储的一种数据，仅仅是浏览器实现的一种数据存储功能。")]),o._v(" "),s("p",[o._v("cookie由服务器生成，发送给浏览器，浏览器把cookie以"),s("strong",[o._v("kv")]),o._v("形式保存到某个目录下的文本文件内，下一次请求同一网站时会把该cookie发送给服务器。由于cookie是存在客户端上的，所以浏览器加入了一些限制确保cookie不会被恶意使用，同时不会占据太多磁盘空间，所以每个域的cookie数量是有限的。")]),o._v(" "),s("h3",{attrs:{id:"_2-2-什么是session"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-什么是session"}},[o._v("#")]),o._v(" 2.2 什么是Session")]),o._v(" "),s("p",[o._v("session 从字面上讲，就是会话。这个就类似于你和一个人交谈，你怎么知道当前和你交谈的是张三而不是李四呢？对方肯定有某种特征（长相等）表明他就是张三。")]),o._v(" "),s("p",[o._v("session 也是类似的道理，服务器要知道当前发请求给自己的是谁。为了做这种区分，服务器就要给每个客户端分配不同的“身份标识”，然后客户端每次向服务器发请求的时候，都带上这个“身份标识”，服务器就知道这个请求来自于谁了。至于客户端怎么保存这个“身份标识”，可以有很多种方式，对于浏览器客户端，大家都默认采用 cookie 的方式。")]),o._v(" "),s("p",[o._v("服务器使用session把用户的信息临时保存在了服务器上，用户离开网站后session会被销毁。这种用户信息存储方式相对cookie来说更安全，可是session有一个缺陷：如果web服务器做了负载均衡，那么下一个操作请求到了另一台服务器的时候session会丢失。")]),o._v(" "),s("h3",{attrs:{id:"_2-3-传统身份验证流程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-传统身份验证流程"}},[o._v("#")]),o._v(" 2.3 传统身份验证流程")]),o._v(" "),s("ul",[s("li",[s("p",[o._v("首先，客户端会发送一个http请求到服务器端。")])]),o._v(" "),s("li",[s("p",[o._v("服务器端接受客户端请求后，建立一个session，并发送一个http响应到客户端，这个响应头，其中就包含Set-Cookie头部。该头部包含了sessionId。Set-Cookie格式如下，具体请看"),s("a",{attrs:{href:"https://link.zhihu.com/?target=http%3A//bubkoo.com/2014/04/21/http-cookies-explained/",target:"_blank",rel:"noopener noreferrer"}},[o._v("Cookie详解"),s("OutboundLink")],1)]),o._v(" "),s("p",[s("code",[o._v("Set-Cookie: value[; expires=date][; domain=domain][; path=path][; secure]")])])]),o._v(" "),s("li",[s("p",[o._v("在客户端发起的第二次请求，假如服务器给了set-Cookie，浏览器会自动在请求头中添加cookie")])]),o._v(" "),s("li",[s("p",[o._v("服务器接收请求，分解cookie，验证信息，核对成功后返回response给客户端")])])]),o._v(" "),s("p",[s("a",{attrs:{href:"https://imgtu.com/i/IUwLB8",target:"_blank",rel:"noopener noreferrer"}},[s("img",{attrs:{src:"https://z3.ax1x.com/2021/11/10/IUwLB8.png",alt:"IUwLB8.png"}}),s("OutboundLink")],1)]),o._v(" "),s("p",[s("strong",[o._v("Cookie与Session的区别")])]),o._v(" "),s("ul",[s("li",[o._v("cookie数据存放在"),s("strong",[o._v("客户端")]),o._v("上，session数据放在服务器上。")]),o._v(" "),s("li",[o._v("cookie不是很安全，别人可以分析存放在本地的cookie并进行cookie欺骗。考虑到安全应当使用session。")]),o._v(" "),s("li",[o._v("session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能，考虑到减轻服务器性能方面，应当使用cookie。")]),o._v(" "),s("li",[o._v("单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。")]),o._v(" "),s("li",[o._v("**个人建议：**将登陆信息等重要信息存放为SESSION；其他信息如果需要保留，可以放在COOKIE中。")])]),o._v(" "),s("p",[s("strong",[o._v("注意")])]),o._v(" "),s("ul",[s("li",[o._v("cookie只是实现session的"),s("strong",[o._v("其中一种方案")]),o._v("。虽然是最常用的，但并不是唯一的方法。禁用cookie后还有其他方法存储，比如放在url中。")]),o._v(" "),s("li",[o._v("现在大多都是Session + Cookie，但是只用session不用cookie，或是只用cookie，不用session在理论上都可以保持会话状态。可是实际中因为多种原因，一般不会单独使用。")]),o._v(" "),s("li",[o._v("如果只用cookie不用session，那么账户信息全部保存在客户端，一旦被劫持，全部信息都会泄露。并且客户端数据量变大，网络传输的数据量也会变大。")])]),o._v(" "),s("p",[s("strong",[o._v("小结")])]),o._v(" "),s("p",[s("strong",[o._v("简而言之，session 又如用户信息档案表，里面包含了用户的认证信息和登录状态等信息.。而 cookie 就是用户通行证。")])]),o._v(" "),s("h2",{attrs:{id:"_3-token"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-token"}},[o._v("#")]),o._v(" 3. Token")]),o._v(" "),s("h3",{attrs:{id:"_3-1-什么是token"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-1-什么是token"}},[o._v("#")]),o._v(" 3.1 什么是Token")]),o._v(" "),s("p",[o._v("Token是服务端生成的一串字符串，以作客户端进行请求的一个令牌，当第一次登录后，服务器生成一个Token后便将此Token返回给客户端，以后客户端只需带上这个Token前来请求数据即可，无需再次带上用户名和密码。最简单的Token组成：uid(用户唯一的身份标识)、time(当前时间的时间戳)、sign(签名，由Token的前几位+盐以哈希算法压缩成一定长的十六进制字符串，可以防止恶意第三方拼接Token请求服务器)。")]),o._v(" "),s("p",[o._v("Token 的认证方式类似于"),s("strong",[o._v("临时的证书签名")]),o._v("，并且是一种服务端无状态的认证方式，非常适合于 REST API 的场景。所谓无状态就是服务端并不会保存身份认证相关的数据。")]),o._v(" "),s("p",[s("strong",[o._v("组成")])]),o._v(" "),s("ul",[s("li",[o._v("uid: 用户唯一身份标识")]),o._v(" "),s("li",[o._v("time: 当前时间的时间戳")]),o._v(" "),s("li",[o._v("sign: 签名，使用 hash/encrypt 压缩成定长的十六进制字符串，以防止第三方恶意拼接")]),o._v(" "),s("li",[o._v("固定参数(可选): 将一些常用的固定参数加入到 Token 中是为了避免重复查库")])]),o._v(" "),s("p",[s("strong",[o._v("存放")])]),o._v(" "),s("p",[o._v("Token在客户端一般存放于localStorage，cookie，或sessionStorage中。在服务器一般存于数据库中")]),o._v(" "),s("p",[s("strong",[o._v("Token的引入")])]),o._v(" "),s("p",[o._v("Token是在客户端频繁向服务端请求数据，服务端频繁的去数据库查询用户名和密码并进行对比，判断用户名和密码正确与否，并作出相应提示，在这样的背景下，Token便应运而生。")]),o._v(" "),s("p",[s("strong",[o._v("使用Token的目的")])]),o._v(" "),s("p",[o._v("Token的目的是为了减轻服务器的压力，减少频繁的查询数据库，使服务器更加健壮。")]),o._v(" "),s("p",[s("strong",[o._v("session与token的区别")])]),o._v(" "),s("ul",[s("li",[o._v("session 和 oauth token并不矛盾，作为身份认证 token安全性比session好，因为每个请求都有签名还能防止监听以及重放攻击，而session就必须靠链路层来保障通讯安全了。如上所说，如果你需要实现有状态的会话，仍然可以增加session来在服务器端保存一些状态")]),o._v(" "),s("li",[o._v("App通常用restful api跟server打交道。Rest是stateless的，也就是app不需要像browser那样用cookie来保存session,因此用session token来标示自己就够了，session/state由api server的逻辑处理。 如果你的后端不是stateless的rest api, 那么你可能需要在app里保存session。可以在app里嵌入webkit,用一个隐藏的browser来管理cookie session.")])]),o._v(" "),s("h3",{attrs:{id:"_3-2-token认证流程"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-2-token认证流程"}},[o._v("#")]),o._v(" 3.2 Token认证流程")]),o._v(" "),s("p",[o._v("Token 的认证流程与cookie很相似")]),o._v(" "),s("ul",[s("li",[o._v("用户登录，成功后服务器返回Token给客户端。")]),o._v(" "),s("li",[o._v("客户端收到数据后保存在客户端")]),o._v(" "),s("li",[o._v("客户端再次访问服务器，将Token放入headers中")]),o._v(" "),s("li",[o._v("服务器端采用filter过滤器校验。校验成功则返回请求数据，校验失败则返回错误码")])]),o._v(" "),s("h3",{attrs:{id:"_3-3-两个常见问题"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3-3-两个常见问题"}},[o._v("#")]),o._v(" 3.3 两个常见问题")]),o._v(" "),s("p",[s("strong",[o._v("服务器上的token存储到数据库中，每次查询会不会很费时。如果不存储到数据库，应该存储到哪里呢？")])]),o._v(" "),s("blockquote",[s("p",[o._v("token是个易失数据，丢了无非让用户重新登录一下，新浪微博动不动就让我重新登录，反正这事儿我是无所谓啦。所以如果你觉得普通的数据库表撑不住了，可以放到 MSSQL/MySQL 的内存表里（不过据说mysql的内存表性能提升有限），可以放到 Memcache里（讲真，这个是挺常见的策略），可以放到redis里（我做过这样的实现），甚至可以放到 OpenResty 的变量字典里（只要你有信心不爆内存）。")]),o._v(" "),s("p",[o._v("token是个凭条，不过它比门票温柔多了，门票丢了重新花钱买，token丢了重新操作下认证一个就可以了，因此token丢失的代价是可以忍受的——前提是你别丢太频繁，要是让用户隔三差五就认证一次那就损失用户体验了。")]),o._v(" "),s("p",[o._v("基于这个出发点，如果你认为用数据库来保持token查询时间太长，会成为你系统的瓶颈或者隐患，可以放在内存当中。比如memcached、redis，KV方式很适合你对token查询的需求。这个不会太占内存，比如你的token是32位字符串，要是你的用户量在百万级或者千万级，那才多少内存。要是数据量真的大到单机内存扛不住，或者觉得一宕机全丢风险大，只要这个token生成是足够均匀的，高低位切一下分到不同机器上就行，内存绝对不会是问题。")])]),o._v(" "),s("p",[s("strong",[o._v("客户端得到的token肯定要加密存储的，发送token的时候再解密。存储到数据库还是配置文件呢？")])]),o._v(" "),s("blockquote",[s("p",[o._v("客户端方面这个除非你有一个非常安全的办法，比如操作系统提供的隐私数据存储，那token肯定会存在泄露的问题。比如我拿到你的手机，把你的token拷出来，在过期之前就都可以以你的身份在别的地方登录。")]),o._v(" "),s("p",[o._v("解决这个问题的一个简单办法")]),o._v(" "),s("ol",[s("li",[o._v("在存储的时候把token进行对称加密存储，用时解开。")]),o._v(" "),s("li",[o._v("将请求URL、时间戳、token三者进行合并加盐签名，服务端校验有效性。")])]),o._v(" "),s("p",[o._v("这两种办法的出发点都是：窃取你存储的数据较为容易，而反汇编你的程序hack你的加密解密和签名算法是比较难的。然而其实说难也不难，所以终究是防君子不防小人的做法。话说加密存储一个你要是被人扒开客户端看也不会被喷明文存储……")]),o._v(" "),s("p",[o._v("方法1它拿到存储的密文解不开、方法2它不知道你的签名算法和盐，两者可以结合食用。但是如果token被人拷走，他自然也能植入到自己的手机里面，那到时候他的手机也可以以你的身份来用着，这你就瞎了。于是可以提供一个让用户可以主动expire一个过去的token类似的机制，在被盗的时候能远程止损。")]),o._v(" "),s("p",[o._v("在网络层面上token明文传输的话会非常的危险，所以建议一定要使用HTTPS，并且把token放在post body里。")])]),o._v(" "),s("h2",{attrs:{id:"_4-token可以抵抗csrf-cookie-session不行"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4-token可以抵抗csrf-cookie-session不行"}},[o._v("#")]),o._v(" 4. Token可以抵抗csrf，cookie+session不行")]),o._v(" "),s("p",[o._v("假如用户正在登陆银行网页，同时登陆了攻击者的网页，并且银行网页未对csrf攻击进行防护。攻击者就可以在网页放一个表单，该表单提交src为"),s("code",[o._v("http://www.bank.com/api/transfer")]),o._v("，body为"),s("code",[o._v("count=1000&to=Tom")]),o._v("。倘若是session+cookie，用户打开网页的时候就已经转给Tom1000元了。因为form 发起的 POST 请求并不受到浏览器同源策略的限制，因此可以任意地使用其他域的 Cookie 向其他域发送 POST 请求，形成 CSRF 攻击。在post请求的瞬间，cookie会被浏览器自动添加到请求头中。但Token不同，Token是开发者为了防范csrf而特别设计的令牌，浏览器不会自动添加到headers里，攻击者也无法访问用户的Token，所以提交的表单无法通过服务器过滤，也就无法形成攻击。")]),o._v(" "),s("h2",{attrs:{id:"_5-总结"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_5-总结"}},[o._v("#")]),o._v(" 5. 总结")]),o._v(" "),s("ul",[s("li",[o._v("session存储于服务器，可以理解为一个状态列表，拥有一个唯一识别符号sessionId，通常存放于cookie中。服务器收到cookie后解析出sessionId，再去session列表中查找，才能找到相应session。依赖cookie")]),o._v(" "),s("li",[o._v("cookie类似一个令牌，装有sessionId，存储在客户端，浏览器通常会自动添加。")]),o._v(" "),s("li",[o._v("Token也类似一个令牌，无状态，用户信息都被加密到Token中，服务器收到Token后解密就可知道是哪个用户。需要开发者手动添加。")]),o._v(" "),s("li",[o._v("jwt只是一个跨域认证的方案")])]),o._v(" "),s("h3",{attrs:{id:"补充"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#补充"}},[o._v("#")]),o._v(" "),s("strong",[o._v("补充")])]),o._v(" "),s("p",[s("strong",[o._v("只要关闭浏览器 ，session就消失了？")])]),o._v(" "),s("blockquote",[s("p",[o._v("不对。对session来说，除非程序通知服务器删除一个session，否则服务器会一直保留，程序一般都是在用户做log off的时候发个指令去删除session。")]),o._v(" "),s("p",[o._v("然而浏览器从来不会主动在关闭之前通知服务器它将要关闭，因此服务器根本不会有机会知道浏览器已经关闭，之所以会有这种错觉，是大部分session机制都使用会话cookie来保存session id，而关闭浏览器后这个session id就消失了，再次连接服务器时也就无法找到原来的session。如果服务器设置的cookie被保存在硬盘上，或者使用某种手段改写浏览器发出的HTTP请求头，把原来的session id发送给服务器，则再次打开浏览器仍然能够打开原来的session.")]),o._v(" "),s("p",[o._v("恰恰是由于关闭浏览器不会导致session被删除，迫使服务器为session设置了一个失效时间，当距离客户端上一次使用session的时间超过这个失效时间时，服务器就可以以为客户端已经停止了活动，才会把session删除以节省存储空间。")])]),o._v(" "),s("p",[s("strong",[o._v("JWT")])]),o._v(" "),s("ul",[s("li",[o._v("JWT就是Token的一种实现方式，并且基本是java web领域的事实标准。")]),o._v(" "),s("li",[o._v("JWT全称是JSON Web Token。基本可以看出是使用JSON格式传输Token")]),o._v(" "),s("li",[o._v("JWT 由 3 部分构成:")]),o._v(" "),s("li",[o._v("Header :描述 JWT 的元数据。定义了生成签名的算法以及 Token 的类型。Payload（负载）:用来存放实际需要传递的数据Signature（签名）：服务器通过Payload、Header和一个密钥(secret)使用 Header 里面指定的签名算法（默认是 HMAC SHA256）生成。流程：")]),o._v(" "),s("li",[o._v("在基于 Token 进行身份验证的的应用程序中，用户登录时，服务器通过Payload、Header和一个密钥(secret)创建令牌（Token）并将 Token 发送给客户端，")]),o._v(" "),s("li",[o._v("然后客户端将 Token 保存在 Cookie 或者 localStorage 里面，以后客户端发出的所有请求都会携带这个令牌。你可以把它放在 Cookie 里面自动发送，但是这样不能跨域，所以更好的做法是放在 HTTP Header 的 Authorization字段中：Authorization: 你的Token。")])]),o._v(" "),s("p",[s("strong",[o._v("Ref：")]),s("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/92949110",target:"_blank",rel:"noopener noreferrer"}},[o._v("巨人的肩膀"),s("OutboundLink")],1),o._v(" "),s("a",{attrs:{href:"https://www.cnblogs.com/JamesWang1993/p/8593494.html",target:"_blank",rel:"noopener noreferrer"}},[o._v("巨人的肩膀"),s("OutboundLink")],1)])])}),[],!1,null,null,null);e.default=_.exports}}]);